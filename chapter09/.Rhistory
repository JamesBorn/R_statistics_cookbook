previous_value = values
for (x in 1:200){
current_value  = coef*previous_value + rnorm(1,0,10)
values         = c(values,current_value)
previous_value = current_value
}
return (values)
}
ss1 = build_series(1)
ss2 = build_series(1)
ss3 = build_series(1)
par(mfrow=c(1,1))
plot(ss1,type="l",ylim=c(-100,100))
lines(ss3,col="green")
set.seed(15)
build_series = function(coef){
start_value    = 90
values         = c(start_value)
previous_value = values
for (x in 1:200){
current_value  = coef*previous_value + rnorm(1,0,10)
values         = c(values,current_value)
previous_value = current_value
}
return (values)
}
ss1 = build_series(1)
ss2 = build_series(1)
ss3 = build_series(1)
par(mfrow=c(1,1))
plot(ss1,type="l",ylim=c(-80,150))
lines(ss3,col="green")
set.seed(15)
build_series = function(coef){
start_value    = 90
values         = c(start_value)
previous_value = values
for (x in 1:200){
current_value  = coef*previous_value + rnorm(1,0,10)
values         = c(values,current_value)
previous_value = current_value
}
return (values)
}
ss1 = build_series(1)
ss2 = build_series(1)
ss3 = build_series(1)
par(mfrow=c(1,1))
plot(ss1,type="l",ylim=c(-80,200))
lines(ss3,col="green")
set.seed(15)
build_series = function(coef){
start_value    = 90
values         = c(start_value)
previous_value = values
for (x in 1:200){
current_value  = coef*previous_value + rnorm(1,0,10)
values         = c(values,current_value)
previous_value = current_value
}
return (values)
}
ss1 = build_series(1)
ss2 = build_series(1)
ss3 = build_series(1)
par(mfrow=c(1,1))
plot(ss1,type="l",ylim=c(-80,250))
lines(ss3,col="green")
set.seed(25)
build_series = function(coef){
start_value    = 90
values         = c(start_value)
previous_value = values
for (x in 1:200){
current_value  = coef*previous_value + rnorm(1,0,10)
values         = c(values,current_value)
previous_value = current_value
}
return (values)
}
ss1 = build_series(1)
ss2 = build_series(1)
ss3 = build_series(1)
par(mfrow=c(1,1))
plot(ss1,type="l",ylim=c(-80,250))
lines(ss3,col="green")
set.seed(35)
build_series = function(coef){
start_value    = 90
values         = c(start_value)
previous_value = values
for (x in 1:200){
current_value  = coef*previous_value + rnorm(1,0,10)
values         = c(values,current_value)
previous_value = current_value
}
return (values)
}
ss1 = build_series(1)
ss2 = build_series(1)
ss3 = build_series(1)
set.seed(35)
build_series = function(coef){
start_value    = 90
values         = c(start_value)
previous_value = values
for (x in 1:200){
current_value  = coef*previous_value + rnorm(1,0,10)
values         = c(values,current_value)
previous_value = current_value
}
return (values)
}
ss1 = build_series(1)
ss2 = build_series(1)
ss3 = build_series(1)
set.seed(95)
build_series = function(coef){
start_value    = 90
values         = c(start_value)
previous_value = values
for (x in 1:200){
current_value  = coef*previous_value + rnorm(1,0,10)
values         = c(values,current_value)
previous_value = current_value
}
return (values)
}
ss1 = build_series(1)
ss2 = build_series(1)
ss3 = build_series(1)
set.seed(95)
build_series = function(coef){
start_value    = 90
values         = c(start_value)
previous_value = values
for (x in 1:200){
current_value  = coef*previous_value + rnorm(1,0,10)
values         = c(values,current_value)
previous_value = current_value
}
return (values)
}
ss1 = build_series(1)
ss2 = build_series(1)
ss3 = build_series(1)
par(mfrow=c(1,1))
plot(ss1,type="l",ylim=c(-80,250))
lines(ss3,col="green")
set.seed(95)
build_series = function(coef){
start_value    = 90
values         = c(start_value)
previous_value = values
for (x in 1:200){
current_value  = coef*previous_value + rnorm(1,0,10)
values         = c(values,current_value)
previous_value = current_value
}
return (values)
}
ss1 = build_series(1)
ss2 = build_series(1)
ss3 = build_series(1)
par(mfrow=c(1,1))
plot(ss1,type="l",ylim=c(-80,250))
set.seed(95)
build_series = function(coef){
start_value    = 90
values         = c(start_value)
previous_value = values
for (x in 1:200){
current_value  = coef*previous_value + rnorm(1,0,10)
values         = c(values,current_value)
previous_value = current_value
}
return (values)
}
ss1 = build_series(1)
ss2 = build_series(1)
ss3 = build_series(1)
par(mfrow=c(1,1))
plot(ss1,type="l",ylim=c(-80,250))
ss2
set.seed(95)
build_series = function(coef){
start_value    = 90
values         = c(start_value)
previous_value = values
for (x in 1:200){
current_value  = coef*previous_value + rnorm(1,0,10)
values         = c(values,current_value)
previous_value = current_value
}
return (values)
}
ss1 = build_series(1)
ss2 = build_series(1)
ss3 = build_series(1)
par(mfrow=c(1,1))
plot(ss1,type="l",ylim=c(-80,250))
plot(ss2,col="red")
set.seed(95)
build_series = function(coef){
start_value    = 90
values         = c(start_value)
previous_value = values
for (x in 1:200){
current_value  = coef*previous_value + rnorm(1,0,10)
values         = c(values,current_value)
previous_value = current_value
}
return (values)
}
ss1 = build_series(1)
ss2 = build_series(1)
ss3 = build_series(1)
par(mfrow=c(1,1))
plot(ss1,type="l",ylim=c(-80,250))
set.seed(95)
build_series = function(coef){
start_value    = 90
values         = c(start_value)
previous_value = values
for (x in 1:200){
current_value  = coef*previous_value + rnorm(1,0,10)
values         = c(values,current_value)
previous_value = current_value
}
return (values)
}
ss1 = build_series(1)
ss2 = build_series(1)
ss3 = build_series(1)
plot(ss1,type="l",ylim=c(-80,250))
set.seed(95)
build_series = function(coef){
start_value    = 90
values         = c(start_value)
previous_value = values
for (x in 1:200){
current_value  = coef*previous_value + rnorm(1,0,10)
values         = c(values,current_value)
previous_value = current_value
}
return (values)
}
ss1 = build_series(1)
ss2 = build_series(1)
ss3 = build_series(1)
plot(ss1,type="l",ylim=c(-80,250))
lines(ss2,col="red")
lines(ss3,col="green")
set.seed(95)
build_series = function(coef){
start_value    = 90
values         = c(start_value)
previous_value = values
for (x in 1:200){
current_value  = coef*previous_value + rnorm(1,0,10)
values         = c(values,current_value)
previous_value = current_value
}
return (values)
}
ss1 = build_series(1)
ss2 = build_series(1)
ss3 = build_series(1)
plot(ss1,type="l",ylim=c(-200,300))
lines(ss3,col="green")
set.seed(95)
build_series = function(coef){
start_value    = 90
values         = c(start_value)
previous_value = values
for (x in 1:200){
current_value  = coef*previous_value + rnorm(1,0,10)
values         = c(values,current_value)
previous_value = current_value
}
return (values)
}
ss1 = build_series(1)
ss2 = build_series(1)
ss3 = build_series(1)
plot(ss1,type="l",ylim=c(-200,300))
lines(ss2,col="red")
lines(ss3,col="green")
plot(ss1,type="l",ylim=c(-200,300),main=c("Three nonstationary time series"))
lines(ss2,col="red")
lines(ss3,col="green")
plot(ss1,type="l",ylim=c(-200,300))
lines(ss2,col="red")
lines(ss3,col="green")
s1 = build_series(0.2)
s2 = build_series(0.2)
s3 = build_series(0.2)
plot(s1,type="l",ylim=c(-400,400))
lines(s3,col="green")
set.seed(95)
build_series = function(coef){
start_value    = 90
values         = c(start_value)
previous_value = values
for (x in 1:200){
current_value  = coef*previous_value + rnorm(1,0,10)
values         = c(values,current_value)
previous_value = current_value
}
return (values)
}
ss1 = build_series(1)
ss2 = build_series(1)
ss3 = build_series(1)
plot(ss1,type="l",ylim=c(-200,300))
lines(ss3,col="green")
lines(ss2,col="red")
s1 = build_series(0.2)
s2 = build_series(0.2)
s3 = build_series(0.2)
plot(s1,type="l",ylim=c(-50,50))
lines(s2,col="red")
lines(s3,col="green")
acf(s1)
acf(ss1)
arima(s1,order=c(1,0,0))
arima(s1,order=c(1,0,0),include.mean = FALSE )
arima(s1,order=c(1,0,0),include.mean = FALSE )
acf(ss1)
arima(ss1,order=c(1,0,0),include.mean = FALSE )
s1_d = diff(s1)
plot(s1_d,type="l")
acf(s1_d)
library(caret)
mushroom_data = read.csv("https://archive.ics.uci.edu/ml/machine-learning-databases/mushroom/agaricus-lepiota.data",head=FALSE)
colnames(mushroom_data) = c("edible","cap-shape", "cap-surface", "cap-color","bruises","odor",
"gill-attachment","gill-spacing","gill-size","gill-color","stalk-shape",
"stalk-root","stalk-surface-above-ring","stalk-surface-below-ring","stalk-color-above-ring",
"stalk-color-below-ring","veil-type","veil-color","ring-number","ring-type",
"spore-print-color","population","habitat")
trainIndex <- createDataPartition(mushroom_data$edible, p = .75, list = FALSE, times = 1)
traindata <- mushroom_data[trainIndex,]
testdata <- mushroom_data[-trainIndex,]
total_proportion <- nrow(mushroom_data[mushroom_data$edible=="e",])/nrow(mushroom_data)
train_proportion <- nrow(traindata[traindata$edible=="e",])/nrow(traindata)
test_proportion <- nrow(testdata[testdata$edible=="e",])/nrow(testdata)
print(paste("p of edible in data=",round(total_proportion,3),
"/p of edible in train=",round(train_proportion,3),
"/p of edible in test=",round(test_proportion,3)))
bootstrap_sample <- createResample(mushroom_data$edible,times=10,list=FALSE)
kfolds_results = createFolds(mushroom_data$edible, k=4,list=FALSE)
r1 = nrow(mushroom_data[kfolds_results==1 & mushroom_data$edible=="e",])/nrow(mushroom_data[kfolds_results==1,])
r2 = nrow(mushroom_data[kfolds_results==2 & mushroom_data$edible=="e",])/nrow(mushroom_data[kfolds_results==2,])
r3 = nrow(mushroom_data[kfolds_results==3 & mushroom_data$edible=="e",])/nrow(mushroom_data[kfolds_results==3,])
r4 = nrow(mushroom_data[kfolds_results==4 & mushroom_data$edible=="e",])/nrow(mushroom_data[kfolds_results==4,])
print(paste("proportion of edible in fold1=",r1,
"/proportion of edible in fold2=",r2,
"/proportion of edible in fold3=",r3,
"/proportion of edible in fold4=",r4))
r = rnorm(10,0,1)
createTimeSlices(r,4,horizon=2)
library(MASS)
library(caret)
control <- trainControl(method="repeatedcv", number=4, repeats=1)
tunegrid <- expand.grid(.mtry=c(2,3,4,5,6,7,8))
data <- Boston
train(medv~., data=data,preProcess=c("scale","center","pca"), method="rf", metric="RMSE",
tuneGrid=tunegrid, trControl=control)
train(medv~., data=data, method="rf", metric="RMSE", tuneGrid=tunegrid, trControl=control)
trainIndex <- createDataPartition(Boston$medv, p = .75, list = FALSE, times = 1)
traindata <- Boston[trainIndex,]
testdata <- Boston[-trainIndex,]
preprocess_object <- preProcess(traindata[-14],method=c("scale","center","pca"),pcaComp=4)
x_transformed <- predict(preprocess_object,traindata[-14])
combined_train_data <- cbind(x_transformed,traindata[14])
control <- trainControl(method="none")
tunegrid <- expand.grid(.mtry=c(4))
m3 <- train(medv~., data=combined_train_data, method="rf",
metric="RMSE", tuneGrid=tunegrid, trControl=control)
test_xdata <- predict(preprocess_object,testdata[-14])
y_test_pred <- predict(m3,test_xdata)
postResample(pred = y_test_pred, obs = testdata$medv)
preProcess(traindata[-14],method=c("scale","center","pca"),thresh=0.9)
traindata[1:10,1] = NA
preProcess(traindata[-14],method=c("knnImpute"))
library(MASS)
library(caret)
control <- trainControl(method="repeatedcv", number=4, repeats=1)
tunegrid <- expand.grid(.mtry=c(2,3,4,5,6,7,8))
data <- Boston
train(medv~., data=data,preProcess=c("scale","center","pca"), method="rf", metric="RMSE",
tuneGrid=tunegrid, trControl=control)
train(medv~., data=data, method="rf", metric="RMSE", tuneGrid=tunegrid, trControl=control)
postResample(pred = y_test_pred, obs = testdata$medv)
library(MASS)
library(caret)
control <- trainControl(method="repeatedcv", number=4, repeats=1)
tunegrid <- expand.grid(.mtry=c(2,3,4,5,6,7,8))
data <- Boston
train(medv~., data=data,preProcess=c("scale","center","pca"), method="rf", metric="RMSE",
tuneGrid=tunegrid, trControl=control)
train(medv~., data=data, method="rf", metric="RMSE", tuneGrid=tunegrid, trControl=control)
trainIndex <- createDataPartition(Boston$medv, p = .75, list = FALSE, times = 1)
traindata <- Boston[trainIndex,]
testdata <- Boston[-trainIndex,]
preprocess_object <- preProcess(traindata[-14],method=c("scale","center","pca"),pcaComp=4)
x_transformed <- predict(preprocess_object,traindata[-14])
combined_train_data <- cbind(x_transformed,traindata[14])
control <- trainControl(method="none")
tunegrid <- expand.grid(.mtry=c(4))
m3 <- train(medv~., data=combined_train_data, method="rf",
metric="RMSE", tuneGrid=tunegrid, trControl=control)
test_xdata <- predict(preprocess_object,testdata[-14])
y_test_pred <- predict(m3,test_xdata)
postResample(pred = y_test_pred, obs = testdata$medv)
preProcess(traindata[-14],method=c("scale","center","pca"),thresh=0.9)
traindata[1:10,1] = NA
preProcess(traindata[-14],method=c("knnImpute"))
library(caret)
library(randomForest)
control           <- trainControl(method="repeatedcv", number=4, repeats=1)
tunegrid          <- expand.grid(.mtry=c(2,3,4,5,6,7,8))
data              <- Boston
result            = train(medv~., data=data, method="rf", metric="RMSE", tuneGrid=tunegrid,
trControl=control,importance=TRUE)$finalModel
result
gbmImp            <- varImp(result)
importance(result)
varImpPlot(result)
tunegrid          <- expand.grid(.mtry=c(1))
result            = train(medv~., data=data[,c("medv","rm","lstat")], method="rf", metric="RMSE",
tuneGrid=tunegrid, trControl=control)$finalModel
result
control <- rfeControl(functions=rfFuncs, method="cv", number=10)
results <- rfe(as.matrix(data[-14]),as.matrix(data[14]), sizes=c(1:5), rfeControl=control)
print(results)
predictors(results)
plot(results, type=c("g", "o"))
print(results)
predictors(results)
rctrl1          <- trainControl(method     = "cv",number=5,classProbs = TRUE,summaryFunction =
twoClassSummary)
model1          <- train(Approved_~.,traindata,
method     = "gbm",  verbose=FALSE,
trControl  = rctrl1,metric="ROC",
tuneLength = 10)
predictions_train = predict(model1,traindata)
confusionMatrix(traindata$Approved_,predictions_train)
library(MASS)
library(PRROC)
library(precrec)
library(pROC)
set.seed(10)
data = read.csv("/Users/fjuretig/Documents/approved.csv")
data = data[,-c(1,7)]
data$Approved_ = "not_approved"
data$Approved_[data$Approved == 1] <- "approved"
data$Approved_ = as.factor(data$Approved_)
data = data[,-1]
trainIndex       <- createDataPartition(data$Approved_, p = .75,  list = FALSE,  times = 1)
traindata        <- data[trainIndex,]
testdata         <- data[-trainIndex,]
rctrl1          <- trainControl(method     = "cv",number=5,classProbs = TRUE,summaryFunction =
twoClassSummary)
model1          <- train(Approved_~.,traindata,
method     = "gbm",  verbose=FALSE,
trControl  = rctrl1,metric="ROC",
tuneLength = 10)
library(MASS)
library(PRROC)
library(precrec)
library(pROC)
set.seed(10)
data = read.csv("/Users/fjuretig/Documents/approved.csv")
data = data[,-c(1,7)]
data$Approved_ = "not_approved"
data$Approved_[data$Approved == 1] <- "approved"
data$Approved_ = as.factor(data$Approved_)
data = data[,-1]
setwd("/Users/fjuretig/Documents/R_book/chapter09")
library(MASS)
library(PRROC)
library(precrec)
library(pROC)
set.seed(10)
data = read.csv("./approved.csv")
data = data[,-c(1,7)]
data$Approved_ = "not_approved"
data$Approved_[data$Approved == 1] <- "approved"
data$Approved_ = as.factor(data$Approved_)
data = data[,-1]
trainIndex       <- createDataPartition(data$Approved_, p = .75,  list = FALSE,  times = 1)
traindata        <- data[trainIndex,]
testdata         <- data[-trainIndex,]
rctrl1          <- trainControl(method     = "cv",number=5,classProbs = TRUE,summaryFunction =
twoClassSummary)
model1          <- train(Approved_~.,traindata,
method     = "gbm",  verbose=FALSE,
trControl  = rctrl1,metric="ROC",
tuneLength = 10)
predictions_train = predict(model1,traindata)
confusionMatrix(traindata$Approved_,predictions_train)
predictions_test = predict(model1,testdata)
confusionMatrix(testdata$Approved_,predictions_test)
plot.roc(traindata$Approved_,predict(model1, traindata, type="prob")[,1],main="ROC curves,
black=train,red=test")
plot.roc(testdata$Approved_,predict(model1, testdata, type="prob")[,1],col="red",add=TRUE)
plot.roc(traindata$Approved_,predict(model1, traindata, type="prob")[,1],main="ROC curves,
black=train,red=test")
par(mfrow=c(2,1))
sscurves <- evalmod(scores = predict(model1, traindata, type="prob")[,2], labels = traindata$Approved_)
plot(sscurves)
